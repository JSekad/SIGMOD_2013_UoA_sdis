# softDevForInfSystems3 ()

Ανάπτυξη Λογισμικού για Πληροφοριακά Συστήματα

**sdi1600148 Tsolkas Nikolaos**
**sdi1800241 Agoris Konstantinos**
**sdi1800250 Sekadakis Ioannis**

Τελικό report του project
Στην αρχή σκεφτήκαμε να εφαρμόσουμε παραλληλία σε όλη την συνάρτηση match document. Μετά από δοκιμές παρατηρήσαμε ότι με αυτόν τον τρόπο το πρόγραμμα γίνεται αισθητά πιο αργό καθώς μέσα στη συνάρτηση γίνεται εγγραφή σε αρκετές κοινές δομές με αποτέλεσμα να καθυστερεί. Επίσης σε κάποιες περιπτώσεις το πρόγραμμα επέστρεφε και λάθος αποτελέσματα. Καταλήξαμε στο συμπέρασμα ότι έτσι, ουσιαστικά, το πρόγραμμα δεν γίνεται παράλληλο αφού και πάλι οι περισσότερες εργασίες γίνονται σειριακά.

Στη συνέχεια υλοποιήσαμε την παραλληλία μέσα στην συνάρτηση σπάζοντας ουσιαστικά την match document σε τρεις ξεχωριστές την match_document_edit την match_document_hash match_document_hamming. Κάθε μία από αυτές τις συναρτήσεις ελέγχει την αντίστοιχη δομή που της αναλογεί και βρίσκει ποιες λέξεις ταιριάζουν με την κάθε λέξη του document κάθε φορά. Στη συνέχεια τοποθετούν η κάθε μία τα αποτελέσματά της σε με μία λίστα ξεχωριστή για την κάθε μια. Αφού τελειώσουν όλες οι συναρτήσεις, δηλαδή τα threads, οι τρεις ξεχωριστές λίστες γίνονται merge και έχουμε μία συνολική λίστα την οποία στη συνέχεια διατρέχουμε με σκοπό να απορρίψουμε τα λανθασμένα queries και να μείνουμε εν τέλει με μία λίστα η οποία έχει τα σωστά αποτελέσματα

Όσον αφορά τα threads καταλήξαμε ότι ο ιδανικός αριθμός για την συγκεκριμένη υλοποίηση είναι τα δύο. Μετά από αρκετές δοκιμές είδαμε ότι με παραπάνω threads το πρόγραμμα αργεί περισσότερο και σε κάποιες φάσης ακόμα και μετά από πέντε λεπτά δεν έχει ολοκληρωθεί. Οι εν λόγω δοκιμές έχουν πραγματοποιηθεί στα συστήματα linux που βρίσκονται στο τμήμα. 
![2threads](https://user-images.githubusercontent.com/75496647/150691750-60c56951-2c12-4e88-8b03-b3cc495e2f26.JPG)
Εικόνα 1. Εκτέλεση προγράμματος με 2 ενεργά threads
![3threads](https://user-images.githubusercontent.com/75496647/150691790-ed2b1c53-81c9-47ff-97c6-334ed000ca3e.JPG)
Εικόνα 2. Εκτέλεση προγράμματος με 3 ενεργά threads.
![4threads](https://user-images.githubusercontent.com/75496647/150691811-968e9625-8ac7-4e6b-a7bd-3219c6c866c9.JPG)
Εικόνα 3. Εκτέλεση προγράμματος με 4 ενεργά threads
Με 5 ενεργά threads το πρόγραμμα ακόμα και δέκα λεπτά μετά την έναρξη του δεν είχε ολοκληρωθεί.



Στα προσωπικά μας μηχανήματα χρησιμοποιώντας αυτή την μορφή της παραλληλίας παρατηρήσαμε μια μικρή διαφορά το σε κάποιες περιπτώσεις ανάλογα με τον αριθμό των threads. 
![271894672_232207152436354_386859506956159140_n](https://user-images.githubusercontent.com/75496647/150691825-20be3ed2-cdfa-45c8-8d92-240f66a72ce8.png)
Εικόνα 4. Πριν την εισαγωγή παραλληλίας. 
![271870699_363090488485289_2810466061912161429_n](https://user-images.githubusercontent.com/75496647/150691837-09e24929-444c-45d6-929d-ca423836760a.png)
Εικόνα 5. Μετά την εισαγωγή παραλληλίας.

Για την υλοποίηση των δομών χρησιμοποιήσαμε κατά κύριο λόγο αυτές που είχαμε δημιουργήσει στα πλαίσια της πρώτης εργασίες. 

Για την επεξεργασία του κειμένου χρησιμοποιούμε ένα hash table με μία καλή hash function καθώς αυτός είναι ο πιο γρήγορος τρόπος να διαγράψουμε τις διπλές λέξεις από μέσα, καθώς η εναλλακτική που ήταν ο πίνακας θα χρειαζόταν να διατρέχουμε κάθε φορά τον πίνακα για να ελέγξουμε κάτι το οποίο θα ήταν αρκετά χρονοβόρο. Αφού διαγράψουμε τις διπλότυπες λέξεις από το κείμενο στη συνέχεια τις τοποθετούμε μέσα σε μία δομή entry list την οποία έχουμε δημιουργήσει στα πλαίσια της πρώτης εργασίας και η οποία ουσιαστικά είναι μια συνδεδεμένη λίστα. Στη συνέχεια για κάθε μία λέξη κάνουμε την αναζήτηση όπως αναφέρθηκε προηγουμένως σε κάθε δομή για να βρούμε τα σωστά αποτελέσματα.
Εκτός των δομών τη πρώτης εργασίας, μια entrylist μια δομή entry και ένα bktree έχουμε υλοποιήσει και μία δομή vector η οποία είναι και αρκετά χρήσιμη στην εύκολη αποθήκευση πληροφοριών. Την δομή αυτή την χρησιμοποιούμε αρχικά για την αποθήκευση των queries τα οποία δίνονται κατά τη διάρκεια της εκτέλεσης. Πέρα από αυτό χρησιμοποιείται για την αποθήκευση των document αρχείων αλλά και για τα αποτελέσματα τα οποία επιστρέφονται κάθε φορά μετά την κλήση της match document.

Επίσης προσπαθήσαμε να υλοποιήσουμε την παραλληλία και σε άλλες συναρτήσεις πέρα από την match document. Μία ήταν και η insert η οποία εισάγει τα queries στις αντίστοιχες δομές. Μετά από δοκιμές παρατηρήσαμε ότι και εκεί καθώς η μνήμη είναι διαμοιραζόμενη το πρόγραμμα δεν εκτελείται πιο γρήγορα καθώς τα thread θα πρέπει να περιμένουν συνεχώς το ένα το άλλο.

